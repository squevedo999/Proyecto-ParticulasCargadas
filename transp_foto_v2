%Transporte de electrones 

clear all;
close all;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Constantes
mu_atot = ;
mu_afoto = ;
mu_pfoto = ;
mu_ptot = ;


tot_fotones = 1000; %numero de fotones 
E = espectro_e(tot_fotones);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Dimensiones de las capas
xmaxa = 1000; %Espesor 1000mm
ymaxa = 10; %largo 10mm
zmaxa = 10; %ancho 10mm
area_Pb = 10*10;
xmaxp = xmaxa + 1; %Espesor 1mm del blindaje
ymaxp = ymaxa ; %Largo 10mm del blindaje
zmaxp = zmaxa ; %Ancho 10mm del blindaje

fotones = [0]; %inicializa el vector con todas las energias de fotones

for i = 1:150 %genera vector con todas las energias
    m = E(1,i);
    for j = 1:m
        fotones = [fotones i];
    end
    
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


fotones_abs_aire = 0;
fotones_abs_Pb = 0;
mc2 = 0.511;% Esto es en MeV, falta revisar si la salida de espectro es en MeV o eV

%falta hacer que revise la distancia recorrida para que si sigue en aire o
%si entro al plomo
%hay que programar el cambio a plomo
%falta incluir el cambio en el coeficiente de atenuacion despues de que la
%energia cambia por Compton

for i = 1:numel(fotones)
    
        e(i) = fotones(1,i);
        x(i) = 0;
        y(i) = 0;
        z(i) = 0;

        absorbido = 0;
        
        while absorbido==0
            if e(i)>0.001 %revisa que el foton tenga una energia minima de 0.001 MeV
                
                if x(i)< xmaxa ||  y(i)< ymaxa  || z(i)< zmaxa %si no se sale de las dimensiones del aire
                    d = -log(rand())/mu_atot; %distancia que recorre el foton
                    x(i) = x(i) + d; %distancia que ocurre la interacción
                    
                    if rand()<mu_afoto/mu_atot %Pregunta si es fotoelectrico

                        absorbido = 1;
                        fotones_abs = fotones_abs+1;

                    else %Si no, es Compton

                        theta = asin(-1+2*rand());
                        phi = 2*pi*rand();

                        dx = d*sin(theta)*cos(phi);
                        dy = d*sin(theta)*sin(phi);
                        dz = d*cos(phi);

                        x(i) = x(i) + dx;
                        y(i) = y(i) + dy;
                        z(i) = z(i) + dz;
                    
                        e(i) = (e(i)/(1+(e(i)/(mc2))*(1-cos(theta)))); %no estoy seguro que ese sea el angulo correcto
                    end
                end
                if (xmaxa < x(i) && x(i) < xmaxp)  ||  (ymaxa < y(i) && x(i) < ymaxp)  || (zmaxa < z(i) && x(i) < zmaxp) %si se sale del aire pero esta en plomo
                    d = -log(rand())/mu_ptot; %distancia que recorre el electron
                    x(i) = x(i) + d; %distancia que ocurre la interacción  
                    
                    if rand()<mu_pfoto/mu_ptot %Pregunta si es fotoelectrico

                        absorbido = 1;
                        fotones_abs_Pb = fotones_abs_Pb +1;

                    else %Si no es Compton

                        theta = asin(-1+2*rand());
                        phi = 2*pi*rand();

                        dx = d*sin(theta)*cos(phi);
                        dy = d*sin(theta)*sin(phi);
                        dz = d*cos(phi);

                        x(i) = x(i) + dx;
                        y(i) = y(i) + dy;
                        z(i) = z(i) + dz; 
                        
                        e(i) = (e(i)/(1+(e(i)/(mc2))*(1-cos(theta))));
                    end
                end
              if x(i)> xmaxp ||  y(i)> ymaxp  || z(i)> zmaxp
                  absorbido = 1; %Si ya se sale del plomo equivale a que termina el ciclo
              end

            else %si la energía es menor a 0.001 MeV entonces lo tomamos como absorbido
                if x(i)< xmaxa ||  y(i)< ymaxa  || z(i)< zmaxa %se verifica si se absorbió en aire
                    absorbido = 1;
                    fotones_abs_aire = fotones_abs_aire+1;
                end
                if x(i)< xmaxa ||  y(i)< ymaxa  || z(i)< zmaxa %se verifica si se absorbió en agua
                    absorbido = 1;
                    fotones_abs_Pb = fotones_abs_Pb+1;
                end
            end
        end 
    
end
fotones_antes_blindaje = tot_fotones - fotones_abs_aire; %número de fotones que llegan al blindaje
fotones_despues_blindaje = tot_fotones - (fotones_abs_aire+fotones_abs_Pb); %número de fotones que llegan al blindaje
fluencia_antes_blindaje = fotones_antes_blindaje/area_Pb;
fluencia_despues_blindaje = fotones_despues_blindaje/area_Pb;
